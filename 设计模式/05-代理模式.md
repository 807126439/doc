# 代理模式

## 代理模式的应用场景

​	在生活中，我们经常见到这样的场景，如：租房中介、售票黄牛、婚介、经纪人、快递、事务代理、非侵入式日志监听等，这些都是代理模式的实际体现。代理模式（Proxy Pattern）的定义也非常简单，是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用代理模式主要有两个目的：

1. 保护目标对象
2. 增强目标对象

下面我们看一下代理模式的类结构图：

<img src="/Users/dongwenbin/github/doc/设计模式/assets/image-20190917082113371.png" alt="image-20190917082113371" style="zoom:30%;" />

Subject是顶层接口，RealSubject是真实对象（被代理对象），Proxy是代理对象，代理对象持有被代理对象的引用，客户端调用代理对象方法，同事也调用被代理对象的方法，但是在代理对象前后增加一些处理。在代码中，我们想到代理，就会理解是代码增强，其实就是在原本逻辑前后增加一些逻辑，而调用者无感知。**代理模式有静态代理和动态**

## 静态代理

举个例子：人到了适婚年龄，父母总是迫不及待希望早点抱孙子。而现在社会的人在各种压力之下，都选择晚婚晚育。于是着急的父母就开始到处为自己的子女相亲，比子女自己还着急。这个相亲的过程，就是一种我们人人都有份的代理。来看看代码实现。

顶层接口Person:

```java
package com.wenbin.design.pattern.proxy.staticproxy;

public interface Person {
    void findLove();
}
```

儿子要找对象Son类：

```java
package com.wenbin.design.pattern.proxy.staticproxy;

public class Son implements Person {

    public void findLove() {
        System.out.println("儿子要求：肤白貌美大长腿");
    }
}
```

父亲要帮儿子相亲，实现Father类：

```java
package com.wenbin.design.pattern.proxy.staticproxy;

public class Father {
    private Son son;

    public Father(Son son) {
        this.son = son;
    }

    public void findLove() {
        System.out.println("物色对象");
        this.son.findLove();
        System.out.println("双方同意交往，确立关系");
    }
}
```

测试代码：

```java
package com.wenbin.design.pattern.proxy.staticproxy;

public class StaticProxyTest {
    public static void main(String[] args) {
        // 只能帮儿子找对象
        // 不能帮表妹、不能帮陌生人

        Father father = new Father(new Son());
        father.findLove();

    }
}
```

运行结果：

```
物色对象
儿子要求：肤白貌美大长腿
双方同意交往，确立关系

Process finished with exit code 0
```

这里大家可能觉得还是不知道如何将代理模式应用到业务场景中，那么我们在来举例一个实际业务常见。在分布式业务场景中，我们通常会对数据库进行分表，分库分表之后使用Java操作时，就可能需要配置多个数据源，我们通过设置数据源路由来动态切换数据源。先创建Order订单实体：

```java
package com.wenbin.design.pattern.proxy.dbroute;

public class Order {
    private Object orderInfo;
    private Long createTime;
    private String id;

    public Object getOrderInfo() {
        return orderInfo;
    }

    public void setOrderInfo(Object orderInfo) {
        this.orderInfo = orderInfo;
    }

    public Long getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Long createTime) {
        this.createTime = createTime;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}
```

创建OrderDao持久层操作类：

```java
package com.wenbin.design.pattern.proxy.dbroute;

public class OrderDao {
    public int insert(Order order) {
        System.out.println("OrderDao创建Order成功");
        return 1;
    }
}
```

创建IOrderService接口：

```java
package com.wenbin.design.pattern.proxy.dbroute;

public interface IOrderService {
    int createOrder(Order order);
}
```

创建OrderService实现类：

```java
package com.wenbin.design.pattern.proxy.dbroute;

public class OrderService implements IOrderService {

    private OrderDao orderDao;

    public OrderService() {
        this.orderDao = new OrderDao();
    }

    public int createOrder(Order order) {
        System.out.println("OrderService调用orderDao创建订单");

        return orderDao.insert(order);
    }
}
```

接线来使用静态代理，主要完成功能是，根据订单创建时间自动按年进行分库。根据开闭原则，原来写好的逻辑我们不去修改，通过代理对象来完成。先创建数据源路由对象，我们使用ThreadLoacal的单例实现，DynamicDateSourceEntry类：

```java
package com.wenbin.design.pattern.proxy.dbroute.db;

/**
 * 动态切换数据源
 */
public class DynamicDataSourceEntry {

    // 默认数据源
    public final static String DEFAULT_SOURCE = null;

    private final static ThreadLocal<String> local = new ThreadLocal<String>();

    private DynamicDataSourceEntry(){}

    /**
     * 清空数据源
     */
    public static void clear() {
        local.remove();
    }

    /**
     * 获取当前正在使用的数据源名字
     * @return
     */
    public static String get() {
        return local.get();
    }

    /**
     * 还原单签切面数据源
     */
    public static void restore() {
        local.set(DEFAULT_SOURCE);
    }

    /**
     * 设置已知名字的数据源
     * @param source
     */
    public static void set(String source) {
        local.set(source);
    }

    /**
     * 根据年份动态设置数据源
     * @param year
     */
    public static void set(int year) {
        local.set("DB_" + year);
    }
}
```

创建切换数据源的代理OrderServiceStaticProxy类：

```java
package com.wenbin.design.pattern.proxy.dbroute.proxy;

import com.wenbin.design.pattern.proxy.dbroute.IOrderService;
import com.wenbin.design.pattern.proxy.dbroute.Order;
import com.wenbin.design.pattern.proxy.dbroute.db.DynamicDataSourceEntry;

import java.text.SimpleDateFormat;
import java.util.Date;

public class OrderServiceStaticProxy implements IOrderService {

    private SimpleDateFormat yearFormat = new SimpleDateFormat("yyyy");

    private IOrderService orderService;

    public OrderServiceStaticProxy(IOrderService orderService) {
        this.orderService = orderService;
    }


    public int createOrder(Order order) {
        before();
        Long time = order.getCreateTime();
        Integer dbRouter = Integer.valueOf(yearFormat.format(new Date(time)));
        System.out.println("静态代理类自动分配到[DB_" + dbRouter + "]数据源处理数据。");
        DynamicDataSourceEntry.set(dbRouter);
        orderService.createOrder(order);
        after();

        return 0;
    }

    private void before() {
        System.out.println("Proxy before method");
    }

    private void after() {
        System.out.println("Proxy after method");
    }
}
```

测试代码：

```java
package com.wenbin.design.pattern.proxy.dbroute;

import com.wenbin.design.pattern.proxy.dbroute.proxy.OrderServiceStaticProxy;

import java.text.SimpleDateFormat;
import java.util.Date;

public class DbRouteStaticProxyTest {
    public static void main(String[] args) {
        try {
            Order order = new Order();

            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
            Date date = sdf.parse("2018/02/09");
            order.setCreateTime(date.getTime());

            IOrderService orderService = new OrderServiceStaticProxy(new OrderService());
            orderService.createOrder(order);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

运行结果：

```
Proxy before method
静态代理类自动分配到[DB_2018]数据源处理数据。
OrderService调用orderDao创建订单
OrderDao创建Order成功
Proxy after method

Process finished with exit code 0
```

符合我们的预期效果。现在我们再来回顾一下类图，看是不是和我们最先画的类结构一 致:

![image-20190917090724294](/Users/dongwenbin/github/doc/设计模式/assets/image-20190917090724294.png)

## 动态代理

​	