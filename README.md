



一步一步建立起从分布式到服务化在到云原生的一套完整技术栈.

### Java8

- [x] Lambda表达式
- [x] 流操作(Stream)
- [ ] HashMap源码分析

### 并发

- [x] 并发编程的基础
- [x] synchronize
- [x] volatile
- [x] AQS底层原理分析
- [x] Condition及源码分析
- [ ] CountDwonLatch及源码分析
- [ ] Semaphore及源码分析
- [ ] Semaphore及原理
- [ ] ConcurrentHashMap源码分析
- [ ] 阻塞队列、原子操作的原理分析
- [ ] 线程池、forkjoin的原理分析

### IO

- [x] BIO,NIO,AIO总结

- [x] NIO框架Netty

### 常用设计模式

​	用好设计模式能帮助我们更好的解决实际问题，设计模式最重要的是解耦。设计模式天天都在用，但自己却无感知。把设计模式作为一个专题，主要是学习设计模式是如何总结经验的，把经验为自己所用。同时也为阅读框架源码打下坚实的基础。在学习设计模式之前，一定要先了解软件设计原则。

示例代码地址：git@github.com:wenbin8/design-pattern.git

- [x] 软件设计的七大原则
- [x] 工厂模式
- [x] 单例模式
- [x] 原型模式
- [x] 代理模式
- [x] 委派模式
- [x] 策略模式
- [x] 模板模式
- [x] 适配器模式
- [x] 装饰者模式
- [x] 观察者模式

### 框架源码分析

Spring:

- [x] Spring5的系统架构和源码构建
- [x] Spring的IOC源码分析
- [x] Spring的DI源码分析
- [x] Spring的AOP源码分析
- [x] Spring MVC源码分析

### 数据库

- [ ] b+Tree的原理与Mysql的innoDB索引原理
- [ ] mySql数据查询性能优化

### JVM

- [ ] JVM运行时数据区的内存管理机制
- [ ] 垃圾收集算法与垃圾收集器
- [ ] 类加载机制与编译优化
- [ ] 性能监控与故障处理

### 分布式

- [ ] 分布式架构演进

#### 分布式基础

- [x] 通信协议Tcp/ip
- [ ] 序列化与反序列化

### 分布式协调服务

- [ ] zookeeper
- [ ] etcd

### 分布式服务治理

- [ ] Dubbo

### 分布式消息通信

- [ ] kafka
- [ ] rabbitMQ

### 分布式缓存

- [ ] MongoDB
- [ ] Redis

### 数据库分库分表

- [ ] Mycat


### 微服务(Spring boot/Spring Cloud)

#### Spring Boot

- [ ] 自动配置\起步依赖\Actuator

#### Spring Cloud

- [ ] Eureka注册中心
- [ ] Ribbon 负载均衡
- [ ] Fegion 声明式服务调用
- [ ] Hystrix 服务熔断降级方式
- [ ] Zuul 实现微服务网关
- [ ] Config 分布式统一配置中心
- [ ] Sleuth 调用链路跟踪
- [ ] BUS 消息总线
- [ ] Spring Boot 与 Spring Cloud 整合

### 云原生

#### Docker

- [ ] 理解docker实现原理(内核支持,和联合文件系统)
- [ ] docker镜像和镜像仓库
- [ ] docker容器启动与资源分配
- [ ] docker数据卷(volumes)
- [ ] docker的网络
- [ ] dockerfile的使用
- [ ] docker Compose 

#### K8S

